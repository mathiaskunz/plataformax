/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.plataformax.swingui;

import com.plataformax.configuration.Configuration;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.io.IOException;
import java.math.BigInteger;
import java.security.AlgorithmParameterGenerator;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidParameterSpecException;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.DHParameterSpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.KeyStroke;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultStyledDocument;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.StyledDocument;
import org.jivesoftware.smack.chat.Chat;
import org.jivesoftware.smack.chat.ChatManager;
import org.jivesoftware.smack.chat.ChatMessageListener;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.util.stringencoder.Base64;
import org.jivesoftware.smackx.jiveproperties.JivePropertiesManager;

/**
 *
 * @author Mathias
 */
public class ConversationFrame extends javax.swing.JFrame {

    private static final String ENTER_KEY = "ENTER";
    private static final String TRANSFORMATION = "AES/CTR/PKCS5PADDING";
    
    private KeyStroke keyStroke;
    private Certificate contactCert;
    private IvParameterSpec IV;
    private BigInteger bytesForIV;

    private Configuration config;
    private BigInteger x;
    private BigInteger y;
    private BigInteger ay;
    private BigInteger ax;
    private BigInteger kSTS;
    private BigInteger p;
    private BigInteger g;
    private AlgorithmParameterGenerator apg;
    private AlgorithmParameters ap;
    private DHParameterSpec dhps;
    private String fullContactName;
    private SecretKey key;

    private String user;
    private String firstReceivedMessage;
    private boolean firstMessage;

    /**
     * Creates new form TelaPrincipal
     *
     * @param config
     * @param contact
     * @param firstMessage
     */
    public ConversationFrame(Configuration config, String contact, boolean firstMessage) {
        this.config = config;
        this.fullContactName = contact;
        this.firstMessage = firstMessage;
        this.user = config.getUser();
        JivePropertiesManager.setJavaObjectEnabled(true);
    }

    private ConversationFrame() {
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        campoMensagem = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        campoDigitarMensagem = new javax.swing.JTextArea();
        botaoEnviar = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        campoMensagem2 = new javax.swing.JTextPane();
        configurationParameterButton = new javax.swing.JButton();

        setTitle(fullContactName);

        campoMensagem.setColumns(20);
        campoMensagem.setRows(5);
        jScrollPane1.setViewportView(campoMensagem);

        campoDigitarMensagem.setColumns(20);
        campoDigitarMensagem.setRows(5);
        jScrollPane2.setViewportView(campoDigitarMensagem);
        keyStroke = KeyStroke.getKeyStroke(ENTER_KEY);
        Object actionKey = campoDigitarMensagem.getInputMap(
            JComponent.WHEN_FOCUSED).get(keyStroke);
        campoDigitarMensagem.getActionMap().put(actionKey, wrapper);

        botaoEnviar.setText("Enviar");
        botaoEnviar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botaoEnviarActionPerformed(evt);
            }
        });

        jScrollPane3.setViewportView(campoMensagem2);

        configurationParameterButton.setText("Parametros de configuração");
        configurationParameterButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                configurationParameterButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
            .addComponent(jScrollPane2)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(configurationParameterButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(botaoEnviar))
            .addComponent(jScrollPane3)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(botaoEnviar)
                    .addComponent(configurationParameterButton)))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private final Action wrapper = new AbstractAction() {
        @Override
        public void actionPerformed(ActionEvent ae) {
            botaoEnviar.doClick();
        }
    };

    private boolean checkContactCertValidity(String contactAlias) throws KeyStoreException {

        //FAZER VERIFICAÇÃO PARA VER SE O CERTIFICADO REALMENTE PERTENCE A QUEM ESTÁ O ENVIANDO
        //PODE SER QUE O EMITENDE TENHA ENVIADO UM CERTIFICADO DE OUTRO USUÁRIO
        //O QUE OCASIONARIA NA FALHA DA EXECUÇÃO DO PROTOCOLO DE QUALQUER FORMA
        //MAS É BOM VERIFICAR COMO UMA CAMADA EXTRA DE PROTEÇÃO E TALVEZ AJUDE A POUPAR TRABALHO
        return config.checkContactCertValidity(contactAlias);
    }

    /*private void setMessageText(String text) {
        
        StyledDocument document = campoMensagem2.getStyledDocument();
        
        Style style = campoMensagem2.addStyle("contactName", null);

        StyleConstants.setForeground(style, Color.BLUE);
        
        try {
            document.insertString(document.getLength(), "\n" +getContactName() + ": ", style);
        } catch (BadLocationException ex) {
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        StyleConstants.setForeground(style, Color.BLACK);
        
        try {
            document.insertString(document.getLength(), text, style);
        } catch (BadLocationException ex) {
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        this.revalidate();
    }
    
    private void setOwnMessageText(String text){
        StyledDocument document = campoMensagem2.getStyledDocument();
        
        Style style = campoMensagem2.addStyle("username", null);

        StyleConstants.setForeground(style, Color.GREEN);
        
        try {
            document.insertString(document.getLength(), "\n" + user + ": ", style);
        } catch (BadLocationException ex) {
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        StyleConstants.setForeground(style, Color.BLACK);
        
        try {
            document.insertString(document.getLength(), text, style);
        } catch (BadLocationException ex) {
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        this.revalidate();
    }*/
    
    private void setMessageText(String text) {
        campoMensagem.setForeground(Color.blue);
        campoMensagem.setText(campoMensagem.getText() + "\n" + getContactName() + ": ");
        this.revalidate();
        campoMensagem.setForeground(Color.BLACK);
        campoMensagem.setText(campoMensagem.getText() + "\n" + text);
        this.revalidate();
    }

    private void setOwnMessageText(String text) {
        campoMensagem.setForeground(Color.GREEN);
        campoMensagem.setText(campoMensagem.getText() + "\n" + user + ": ");
        this.revalidate();
        campoMensagem.setForeground(Color.BLACK);
        campoMensagem.setText(campoMensagem.getText() + "\n" + text);
        this.revalidate();
    }

    private void setKfromAy() {
        this.kSTS = ay.modPow(x, p);
    }

    private void setKfromAx() {
        this.kSTS = ax.modPow(y, p);
        System.out.println("LENGHT: " + kSTS.bitCount());
    }

    private void setSecretKey() {
        this.key = new SecretKeySpec(kSTS.toByteArray(), 0, 16, "AES");
    }

    private void setBytesForIV() {
        this.bytesForIV = new BigInteger(Arrays.copyOfRange(kSTS.toByteArray(), 0, 16));
    }

    private void setIV() {
        this.IV = new IvParameterSpec(bytesForIV.toByteArray());
    }

    public void setFirstMessage() {
        this.firstMessage = true;
    }

    public String getFullContactName() {
        return this.fullContactName;
    }

    public String getContactName() {
        return this.fullContactName.substring(0, this.fullContactName.indexOf("@"));
    }

    private void incrementBytesForIV() {
        this.bytesForIV = this.bytesForIV.add(BigInteger.ONE);
        System.out.println("BYTESFORIV: " + bytesForIV);
    }

    private String getRemoteUserCN(String dn) {
        if (dn.contains(",")) {
            return dn.substring(3, dn.indexOf(","));
        } else {
            return dn.substring(3);
        }
    }

    private void addRemoteUserCert(X509Certificate remoteUserCert) throws KeyStoreException,
            IOException, NoSuchAlgorithmException, CertificateException {
        if (getRemoteUserCN(remoteUserCert.getSubjectX500Principal().getName())
                .equals(getContactName())) {

            if (config.containsAlias(getContactName())) {
                config.deleteTrustEntry(getContactName());
            }

            config.addTrustEntry(getContactName(), remoteUserCert);
        }
    }

    private String SignData(String messageToSign) throws NoSuchAlgorithmException,
            InvalidKeyException, SignatureException, Exception {
        Signature sig = Signature.getInstance("SHA256withRSA");

        //ATUALMENTE ESTOU TENDO QUE COLOCAR ESSE "1.0." NA FRENTE DO NOME
        //PORQUE, POR ALGUM MOTIVO, O METODO DA CLASSE MYKEY...
        //SÓ ACHA O ALIAS SE TIVER ESSES NUMEROS NA FRENTE
        //PODE SER ALGO RELACIONADO A VERSÃO DE ALGUMA COISA, ASSIM PODE SER QUE VENHA A DAR PROBLEMA
        //NO FUTURO, TENTAR DESCOBRIR A CAUSA DISSO
        sig.initSign(config.getPrivateKey());
        sig.update(messageToSign.getBytes());
        byte[] signature = sig.sign();
        String encodedSignature = Base64.encodeToString(signature);

        return encodedSignature;
    }

    private boolean verifySign(String messageSignature, String messageToCompare)
            throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {

        Signature sig = Signature.getInstance("SHA256withRSA");
        sig.initVerify(contactCert);

        sig.update(messageToCompare.getBytes());

        byte[] decodedSignature = Base64.decode(messageSignature);
        System.out.println("SIGNATURE: " + Arrays.toString(decodedSignature));
        return sig.verify(decodedSignature);
    }

    private String decryptData(String messageEncrypted) throws NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {

        incrementBytesForIV();
        setIV();
        //Não é necessário o padding com CTR, mas estou colocando por capricho
        Cipher dec = Cipher.getInstance(TRANSFORMATION);
        dec.init(Cipher.DECRYPT_MODE, key, IV);

        byte[] decodedMessage = Base64.decode(messageEncrypted);
        byte[] decValue = dec.doFinal(decodedMessage);
        String decryptedMessage = new String(decValue);
        System.out.println("DESCRYPTED MESSAGE: ");
        System.out.println(decryptedMessage);

        return decryptedMessage;
    }

    public String encryptData(String message) throws NoSuchAlgorithmException,
            NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException,
            IllegalBlockSizeException, BadPaddingException {

        incrementBytesForIV();
        setIV();

        Cipher enc = Cipher.getInstance(TRANSFORMATION);
        enc.init(Cipher.ENCRYPT_MODE, key, IV);

        String encString = Base64.encodeToString(enc.doFinal(message.getBytes()));
        System.out.println("ENCRYPTED STRING: " + encString);
        return encString;
    }

    private void prepareSTSProtocol() {
        try {
            apg = AlgorithmParameterGenerator.getInstance("DH");
            apg.init(512);
            ap = apg.generateParameters();
            dhps = (DHParameterSpec) ap.getParameterSpec(DHParameterSpec.class);
            p = dhps.getP();
            g = dhps.getG();
            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            x = new BigInteger(512, random);
            ax = g.modPow(x, p);

        } catch (NoSuchAlgorithmException | InvalidParameterSpecException ex) {
            JOptionPane.showMessageDialog(rootPane, ex.getMessage());
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        }

    }

    private Chat createChat(ChatManager chatmanager) {
        Chat newChat = chatmanager.createChat(fullContactName, new ChatMessageListener() {
            @Override
            public void processMessage(Chat chat, Message message) {
                setMessageText(message.toString());
            }
        });
        return newChat;
    }

    private void sendMessage(String message, Chat newChat) {
        Message newMessage = new Message();

        if (firstMessage) {
            prepareSTSProtocol();
            JivePropertiesManager.addProperty(newMessage, "ax", ax);
            JivePropertiesManager.addProperty(newMessage, "KeyExchangeState", 1);
            JivePropertiesManager.addProperty(newMessage, "p", dhps.getP());
            JivePropertiesManager.addProperty(newMessage, "g", dhps.getG());
            System.out.println(dhps.getP());
            System.out.println(dhps.getG());
            firstMessage = false;
            newMessage.setBody(message);
        } else {
            try {
                String encryptedMessage = encryptData(message);
                String signature = SignData(encryptedMessage);
                JivePropertiesManager.addProperty(newMessage, "signature", signature);
                newMessage.setBody(encryptedMessage);
            } catch (Exception ex) {
                Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        try {
            newChat.sendMessage(newMessage);
            setOwnMessageText(message);
        } catch (Exception e) {
            JOptionPane.showMessageDialog(rootPane, e.getMessage());
            System.out.println(e.getMessage());
        }
    }

    private void sendMessage(Message message) {
        //ChatManager chatmanager = ChatManager.getInstanceFor(config.getConnection());
        Chat newChat = createChat(config.getChatManager());

        try {
            newChat.sendMessage(message);
            //setMensagensText(message.getBody());
        } catch (Exception e) {
            JOptionPane.showMessageDialog(rootPane, e.getMessage());
            System.out.println(e.getMessage());
        }
    }

    private void processFirstPhaseSTS(Message receivedMessage) {
        SecureRandom random;
        firstReceivedMessage = receivedMessage.getBody();
        try {
            random = SecureRandom.getInstance("SHA1PRNG");
            y = new BigInteger(128, random);
            p = new BigInteger(JivePropertiesManager
                    .getProperty(receivedMessage, "p").toString());

            g = new BigInteger(JivePropertiesManager
                    .getProperty(receivedMessage, "g").toString());
            ay = g.modPow(y, p);
            ax = new BigInteger(JivePropertiesManager
                    .getProperty(receivedMessage, "ax").toString());

            setKfromAx();
            String concatAxAy = ax.toString().concat(ay.toString());

            String signedConcat = SignData(concatAxAy);
            setSecretKey();
            setBytesForIV();

            String encrypedSignedConcat = encryptData(signedConcat);

            Certificate ownCertificate = config.getOwnCertificate();

            Message newMessage = new Message();
            JivePropertiesManager.addProperty(newMessage, "ay", ay.toString());
            JivePropertiesManager.addProperty(newMessage, "certificate", ownCertificate);
            JivePropertiesManager.addProperty(newMessage,
                    "EncrypedSignedConcat", encrypedSignedConcat);
            JivePropertiesManager
                    .addProperty(newMessage, "KeyExchangeState", 2);

            sendMessage(newMessage);

        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

    }

    private void processSecondPhaseSTS(Message receivedMessage) {
        ay = new BigInteger(JivePropertiesManager
                .getProperty(receivedMessage, "ay").toString());
        setKfromAy();

        String encryptedData = JivePropertiesManager
                .getProperty(receivedMessage, "EncrypedSignedConcat").toString();

        setSecretKey();
        setBytesForIV();

        String decryptedData;

        try {
            decryptedData = decryptData(encryptedData);

            System.out.println("DECRYPTED: " + decryptedData);

            String concatAxAy = ax.toString().concat(ay.toString());
            Message newMessage = new Message();

            contactCert = (X509Certificate) JivePropertiesManager
                    .getProperty(receivedMessage, "certificate");

            addRemoteUserCert((X509Certificate) contactCert);

            if (checkContactCertValidity(getContactName())) {

                if (verifySign(decryptedData, concatAxAy)) {

                    String signedConcat = SignData(concatAxAy);
                    String encrypedSignedConcat = encryptData(signedConcat);

                    Certificate ownCertificate = config.getOwnCertificate();

                    JivePropertiesManager.addProperty(newMessage, "certificate", ownCertificate);
                    JivePropertiesManager.addProperty(newMessage,
                            "EncrypedSignedConcat", encrypedSignedConcat);
                    JivePropertiesManager
                            .addProperty(newMessage, "KeyExchangeState", 3);
                    sendMessage(newMessage);
                } else {
                    firstMessage = true;
                    System.out.println("Conversação cancelada! Assinatura inválida!");
                    JivePropertiesManager.addProperty(newMessage, "KeyExchangeState", -1);
                    sendMessage(newMessage);
                }
            } else {
                firstMessage = true;
                System.out.println("Conversação cancelada! Certificado digital inválido: "
                        + "Certificado vencido. Comunicação só será aceita com certificado válido");
                JivePropertiesManager.addProperty(newMessage, "KeyExchangeState", -2);
                sendMessage(newMessage);
            }

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException ex) {
            JOptionPane.showMessageDialog(rootPane, "Não foi possível decriptar a mensagem recebida.\n"
                    + "O processo de negociação de chaves foi cancelado.");
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        } catch (KeyStoreException | IOException | CertificateException ex) {
            JOptionPane.showMessageDialog(rootPane, "Erro. Não foi possível adicionar o certificado do contato "
                    + "na truststore ou houve um problema na verificação da validade do mesmo.\n"
                    + "Verificar se o certificado está importado na truststore ou se a truststore existe.");
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        } catch (SignatureException ex) {
            JOptionPane.showMessageDialog(rootPane, "Erro ao tentar verificar a assinatura da concatenação "
                    + " de ax e ay enviada pelo contato. Ou ao tentar assinar a concatenação de ax e ay");
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            JOptionPane.showMessageDialog(rootPane, "Erro ao tentar realizar a assinatura da da concatenação entre "
                    + "ax e ay.");
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        }

    }

    private void processThirdPhaseSTS(Message receivedMessage) {
        String encryptedConcat = JivePropertiesManager
                .getProperty(receivedMessage, "EncrypedSignedConcat")
                .toString();

        try {
            String decryptedConcat = decryptData(encryptedConcat);

            String concatAxAy = ax.toString().concat(ay.toString());

            Message newMessage = new Message();

            contactCert = (X509Certificate) JivePropertiesManager
                    .getProperty(receivedMessage, "certificate");
            addRemoteUserCert((X509Certificate) contactCert);

            if (checkContactCertValidity(getContactName())) {

                if (!verifySign(decryptedConcat, concatAxAy)) {
                    System.out.println("Conversação cancelada! Assinatura inválida!");
                    JivePropertiesManager.addProperty(newMessage, "KeyExchangeState", -1);
                    sendMessage(newMessage);
                } else {
                    System.out.println("FECHOU NEGOCIAÇÃO");
                    setMessageText(firstReceivedMessage);

                    newMessage.setBody(firstReceivedMessage);

                    sendMessage(newMessage);
                }
            } else {
                config.deleteTrustEntry(getContactName());
                System.out.println("Conversação cancelada! Certificado digital inválido: "
                        + "Certificado vencido. Comunicação só será aceita com certificado válido");
                JivePropertiesManager.addProperty(newMessage, "KeyExchangeState", -2);
                sendMessage(newMessage);
            }
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException 
                | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException ex) {
            JOptionPane.showMessageDialog(rootPane, "Não foi possível decriptar a mensagem recebida.\n"
                    + "O processo de negociação de chaves foi cancelado.");
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        } catch (KeyStoreException | IOException | CertificateException ex) {
            JOptionPane.showMessageDialog(rootPane, "Erro. Não foi possível adicionar o certificado do contato "
                    + "na truststore ou houve um problema na verificação da validade do mesmo.\n"
                    + "Verificar se o certificado está importado na truststore ou se a truststore existe.");
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        } catch (SignatureException ex) {
            JOptionPane.showMessageDialog(rootPane, "Erro ao tentar verificar a assinatura da concatenação "
                    + " de ax e ay enviada pelo contato. Ou ao tentar assinar a concatenação de ax e ay");
            Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public final void receiveMessage(Message receivedMessage) {
        //VERIFICA SE É UM PEDIDO PARA TROCA DE CHAVES, OU SEJA, NOVA CONVERSAÇÃO.
        if (JivePropertiesManager
                .getProperty(receivedMessage, "KeyExchangeState") != null) {
            switch (JivePropertiesManager
                    .getProperty(receivedMessage, "KeyExchangeState").toString()) {
                case "-1":
                    setMessageText("Processo de negociação de chaves não completado."
                            + "Conversação cancelada. Motivo: Assinatura inválida.");
                    firstMessage = true;
                    break;
                case "-2":
                    setMessageText("Processo de negociaçãi de chaves não completado."
                            + "Conversação cancelada. Motivo: Certificado digital inválido.");
                    firstMessage = true;
                    break;
                case "1":
                    processFirstPhaseSTS(receivedMessage);
                    break;
                case "2":
                    processSecondPhaseSTS(receivedMessage);
                    break;
                case "3":
                    processThirdPhaseSTS(receivedMessage);
                    break;
            }

        } else if (JivePropertiesManager.getProperty(receivedMessage, "signature") != null) {
            String signature = JivePropertiesManager.getProperty(receivedMessage, "signature").toString();

            try {
                if (verifySign(signature, receivedMessage.getBody())) {
                    setMessageText(decryptData(receivedMessage.getBody()));
                } else {
                    //VER O QUE FAZER COM A CONVERSA QUANDO A ASSINATURA DIGITAL É INVÁLIDA.
                    setMessageText("Assinatura inválida! Mensagem cancelada!");
                }
            } catch (InvalidKeyException ex) {
                Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
            } catch (Exception ex) {
                Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            //VER O QUE FAZER SE CHEGAR UMA MENSAGEM SEM ASSINATURA.
            setMessageText(receivedMessage.getBody());
        }

    }

    private void botaoEnviarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botaoEnviarActionPerformed
        //ChatManager chatmanager = ChatManager.getInstanceFor(config.getConnection());

        sendMessage(campoDigitarMensagem.getText(), createChat(config.getChatManager()));

        campoDigitarMensagem.setText("");
        campoDigitarMensagem.revalidate();
    }//GEN-LAST:event_botaoEnviarActionPerformed

    private void configurationParameterButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_configurationParameterButtonActionPerformed
        String xy;

        if (x == null) {
            xy = y.toString();
        } else {
            xy = x.toString();
        }

        ParametersFrame tp = new ParametersFrame(p.toString(), g.toString(),
                xy, kSTS.toString(), Base64.encodeToString(key.getEncoded()),
                Base64.encodeToString(IV.getIV()));
        tp.setVisible(true);
    }//GEN-LAST:event_configurationParameterButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ConversationFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ConversationFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ConversationFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ConversationFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    new ConversationFrame().setVisible(true);
                } catch (Exception ex) {
                    Logger.getLogger(ConversationFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton botaoEnviar;
    private javax.swing.JTextArea campoDigitarMensagem;
    private javax.swing.JTextArea campoMensagem;
    private javax.swing.JTextPane campoMensagem2;
    private javax.swing.JButton configurationParameterButton;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    // End of variables declaration//GEN-END:variables
}
